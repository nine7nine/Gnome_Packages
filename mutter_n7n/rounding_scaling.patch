From 8fd2485a3dbdeb6596e153951354cc310c7b6a8b Mon Sep 17 00:00:00 2001
From: Adrian Vovk <adrianvovk@gmail.com>
Date: Thu, 6 Oct 2022 16:21:18 -0400
Subject: [PATCH] monitor-manager: Don't use excessively precise scales

Sometimes, when a scale factor calculation becomes too precise, Mutter
ends up choosing a scale factor that doesn't actually cleanly divide the
resolution. After the 0.0001 decimal place, changes in the scale factor
correspond to less than one pixel of resolution, so it doesn't make sense
to find scale factors more precise than that.

For instance, on my 2560x1600 Macbook, Mutter ends up claiming that
1.502347469329834 is a valid scale factor. Clearly, this number
doesn't cleanly divide 2560. With this patch, instead of pursuing
an infinitely more precice number that's closer to 1.5, Mutter
selects a much more appropriate scale factor of 1.6
---
 src/backends/meta-monitor.c | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/src/backends/meta-monitor.c b/src/backends/meta-monitor.c
index e9ea57a3b1..b6a9e73e56 100644
--- a/src/backends/meta-monitor.c
+++ b/src/backends/meta-monitor.c
@@ -1959,7 +1959,14 @@ get_closest_scale_factor_for_resolution (float width,
 
           scaled_w = base_scaled_w + offset;
           current_scale = width / scaled_w;
-          scaled_h = height / current_scale;
+
+          /*
+           * Anything more precise than 0.0001 will always resolve to less than
+           * a pixel. Such a precise scale factor might not cleanly divide the
+           * screen resolution. We truncate the scale's precision here to avoid
+           * this issue.
+           */
+          current_scale = floorf(current_scale * 10000) / 10000;
 
           if (current_scale >= scale + threshold ||
               current_scale <= scale - threshold ||
@@ -1969,6 +1976,7 @@ get_closest_scale_factor_for_resolution (float width,
               return best_scale;
             }
 
+          scaled_h = height / current_scale;
           if (floorf (scaled_h) == scaled_h)
             {
               found_one = TRUE;
-- 
GitLab

From 995518962b4883abd3d095343c46832483c120af Mon Sep 17 00:00:00 2001
From: Adrian Vovk <adrianvovk@gmail.com>
Date: Fri, 7 Oct 2022 01:46:04 -0400
Subject: [PATCH] monitor-manager: Rework default scale factor selection

From the scale factors available to it, Mutter will now try
to select the scale that makes the UI's size as close as possible
to the size it would be on a display at 150 PPI w/o scaling
---
 src/backends/meta-monitor.c | 80 +++++++++++++++----------------------
 1 file changed, 32 insertions(+), 48 deletions(-)

diff --git a/src/backends/meta-monitor.c b/src/backends/meta-monitor.c
index e9ea57a3b1..87f4f1e12d 100644
--- a/src/backends/meta-monitor.c
+++ b/src/backends/meta-monitor.c
@@ -1804,74 +1804,58 @@ meta_monitor_calculate_crtc_pos (MetaMonitor          *monitor,
                                                         out_y);
 }
 
-/* The minimum resolution at which we turn on a window-scale of 2 */
-#define HIDPI_LIMIT 192
-
 /*
- * The minimum screen height at which we turn on a window-scale of 2;
- * below this there just isn't enough vertical real estate for GNOME
- * apps to work, and it's better to just be tiny
+ * We choose a default scale factor such that the UI is as big
+ * as it would be on a display with this DPI without scaling
  */
-#define HIDPI_MIN_HEIGHT 1200
-
-/* From http://en.wikipedia.org/wiki/4K_resolution#Resolutions_of_common_formats */
-#define SMALLEST_4K_WIDTH 3656
+#define UI_SCALE_DPI 150
 
 static float
 calculate_scale (MetaMonitor                *monitor,
                  MetaMonitorMode            *monitor_mode,
                  MetaMonitorScalesConstraint constraints)
 {
-  int resolution_width, resolution_height;
-  int width_mm, height_mm;
-  int scale;
-
-  scale = 1.0;
-
-  meta_monitor_mode_get_resolution (monitor_mode,
-                                    &resolution_width,
-                                    &resolution_height);
-
-  if (resolution_height < HIDPI_MIN_HEIGHT)
-    return scale;
-
-  /* 4K TV */
-  switch (meta_monitor_get_connector_type (monitor))
-    {
-    case META_CONNECTOR_TYPE_HDMIA:
-    case META_CONNECTOR_TYPE_HDMIB:
-      if (resolution_width < SMALLEST_4K_WIDTH)
-        return scale;
-      break;
-    default:
-      break;
-    }
-
-  meta_monitor_get_physical_dimensions (monitor, &width_mm, &height_mm);
+  int width_px, height_px, width_mm, height_mm;
+  float diag_inches;
+  g_autofree float *scales = NULL;
+  int n_scales;
+  float best_scale, best_dpi;
 
   /*
    * Somebody encoded the aspect ratio (16/9 or 16/10) instead of the physical
    * size.
    */
   if (meta_monitor_has_aspect_as_size (monitor))
-    return scale;
+    return 1.0;
 
-  if (width_mm > 0 && height_mm > 0)
+  meta_monitor_get_physical_dimensions (monitor, &width_mm, &height_mm);
+  if (width_mm == 0 || height_mm == 0)
+    return 1.0;
+  diag_inches = sqrtf(width_mm*width_mm + height_mm*height_mm) / 25.4;
+
+  meta_monitor_mode_get_resolution (monitor_mode, &width_px, &height_px);
+
+  scales = meta_monitor_calculate_supported_scales (monitor, monitor_mode,
+                                                    constraints, &n_scales);
+  best_scale = scales[0];
+
+  for (int i = 0; i < n_scales; i++)
     {
-      double dpi_x, dpi_y;
+      float width_scaled, height_scaled, diag_scaled, dpi;
 
-      dpi_x = (double) resolution_width / (width_mm / 25.4);
-      dpi_y = (double) resolution_height / (height_mm / 25.4);
+      width_scaled = (float) width_px / scales[i];
+      height_scaled = (float) height_px / scales[i];
+      diag_scaled = sqrtf(width_scaled*width_scaled + height_scaled*height_scaled);
+      dpi = diag_scaled / diag_inches;
 
-      /*
-       * We don't completely trust these values so both must be high, and never
-       * pick higher ratio than 2 automatically.
-       */
-      if (dpi_x > HIDPI_LIMIT && dpi_y > HIDPI_LIMIT)
-        scale = 2.0;
+      if (i == 0 || fabsf(dpi - UI_SCALE_DPI) < fabsf(best_dpi - UI_SCALE_DPI))
+        {
+          best_scale = scales[i];
+          best_dpi = dpi;
+        }
     }
 
-  return scale;
+  return best_scale;
 }
 
 float
-- 
GitLab

